<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PSP Browser Storage Test</title>
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        h1, h2, h3 {
            color: #333;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .panel {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background: #f9f9f9;
            margin-bottom: 20px;
        }
        button {
            background: #4a76a8;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover {
            background: #3a5f89;
        }
        pre {
            background: #f2f2f2;
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
            margin-top: 10px;
        }
        .log {
            height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            background: #fff;
        }
        .success {
            color: #2e7d32;
            font-weight: bold;
        }
        .error {
            color: #d32f2f;
            font-weight: bold;
        }
        .warning {
            color: #ed6c02;
        }
        .nav-tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
            margin-bottom: 20px;
        }
        .nav-tab {
            padding: 10px 20px;
            cursor: pointer;
        }
        .nav-tab.active {
            border: 1px solid #ddd;
            border-bottom: none;
            background: #fff;
            border-radius: 4px 4px 0 0;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
    </style>
</head>
<body>
    <h1>PSP Browser Storage Test</h1>
    
    <div class="nav-tabs">
        <div class="nav-tab active" data-tab="memory">Memory Storage</div>
        <div class="nav-tab" data-tab="indexeddb">IndexedDB Storage</div>
        <div class="nav-tab" data-tab="orchestrator">Orchestrator</div>
    </div>
    
    <div class="tab-content active" id="memory-tab">
        <div class="panel">
            <h2>Memory Storage Provider</h2>
            <p>This provider stores sessions in memory and is lost when the page refreshes.</p>
            <button id="memory-create-btn">Create Session</button>
            <button id="memory-list-btn">List Sessions</button>
            <button id="memory-load-btn">Load Session</button>
            <button id="memory-delete-btn">Delete Session</button>
        </div>
    </div>
    
    <div class="tab-content" id="indexeddb-tab">
        <div class="panel">
            <h2>IndexedDB Storage Provider</h2>
            <p>This provider stores sessions in the browser's IndexedDB for persistence.</p>
            <button id="indexeddb-create-btn">Create Session</button>
            <button id="indexeddb-list-btn">List Sessions</button>
            <button id="indexeddb-load-btn">Load Session</button>
            <button id="indexeddb-delete-btn">Delete Session</button>
        </div>
    </div>
    
    <div class="tab-content" id="orchestrator-tab">
        <div class="panel">
            <h2>Storage Orchestrator</h2>
            <p>Uses multiple storage providers with caching and fallback support.</p>
            <button id="orchestrator-create-btn">Create Session</button>
            <button id="orchestrator-list-btn">List Sessions</button>
            <button id="orchestrator-load-btn">Load Session</button>
            <button id="orchestrator-delete-btn">Delete Session</button>
        </div>
    </div>
    
    <div class="container">
        <div class="panel">
            <h3>Log</h3>
            <div class="log" id="log"></div>
        </div>
        
        <div class="panel">
            <h3>Current Session</h3>
            <div id="session-info">No session loaded</div>
        </div>
    </div>
    
    <script>
        // Memory Storage Provider implementation
        class MemoryStorageProvider {
            constructor() {
                this.sessions = new Map();
            }
            
            async save(session) {
                // Deep clone to avoid reference issues
                const sessionCopy = JSON.parse(JSON.stringify(this.serializeSession(session)));
                this.sessions.set(session.metadata.id, sessionCopy);
                log(`[MemoryProvider] Saved session ${session.metadata.id}`);
                return Promise.resolve();
            }
            
            async load(id) {
                if (!this.sessions.has(id)) {
                    const error = `Session not found: ${id}`;
                    log(`[MemoryProvider] Error: ${error}`, 'error');
                    return Promise.reject(new Error(error));
                }
                
                log(`[MemoryProvider] Loaded session ${id}`);
                return Promise.resolve(this.deserializeSession(this.sessions.get(id)));
            }
            
            async delete(id) {
                this.sessions.delete(id);
                log(`[MemoryProvider] Deleted session ${id}`);
                return Promise.resolve();
            }
            
            async list() {
                const metadata = Array.from(this.sessions.values()).map(session => session.metadata);
                log(`[MemoryProvider] Listed ${metadata.length} sessions`);
                return Promise.resolve(metadata);
            }
            
            async exists(id) {
                const exists = this.sessions.has(id);
                log(`[MemoryProvider] Session ${id} exists: ${exists}`);
                return Promise.resolve(exists);
            }
            
            serializeSession(session) {
                const serialized = {
                    metadata: session.metadata,
                    state: { ...session.state }
                };
                
                // Convert localStorage Map
                if (session.state.storage?.localStorage instanceof Map) {
                    serialized.state.storage = { ...serialized.state.storage };
                    const localStorage = {};
                    
                    for (const [origin, storage] of session.state.storage.localStorage.entries()) {
                        localStorage[origin] = Object.fromEntries(storage);
                    }
                    
                    serialized.state.storage.localStorage = localStorage;
                }
                
                // Convert sessionStorage Map
                if (session.state.storage?.sessionStorage instanceof Map) {
                    serialized.state.storage = { ...serialized.state.storage };
                    const sessionStorage = {};
                    
                    for (const [origin, storage] of session.state.storage.sessionStorage.entries()) {
                        sessionStorage[origin] = Object.fromEntries(storage);
                    }
                    
                    serialized.state.storage.sessionStorage = sessionStorage;
                }
                
                return serialized;
            }
            
            deserializeSession(data) {
                const deserialized = {
                    metadata: data.metadata,
                    state: { ...data.state }
                };
                
                // Convert localStorage object to Map
                if (data.state.storage?.localStorage && typeof data.state.storage.localStorage === 'object') {
                    deserialized.state.storage = { ...deserialized.state.storage };
                    const localStorage = new Map();
                    
                    for (const [origin, storage] of Object.entries(data.state.storage.localStorage)) {
                        localStorage.set(origin, new Map(Object.entries(storage)));
                    }
                    
                    deserialized.state.storage.localStorage = localStorage;
                }
                
                // Convert sessionStorage object to Map
                if (data.state.storage?.sessionStorage && typeof data.state.storage.sessionStorage === 'object') {
                    deserialized.state.storage = { ...deserialized.state.storage };
                    const sessionStorage = new Map();
                    
                    for (const [origin, storage] of Object.entries(data.state.storage.sessionStorage)) {
                        sessionStorage.set(origin, new Map(Object.entries(storage)));
                    }
                    
                    deserialized.state.storage.sessionStorage = sessionStorage;
                }
                
                return deserialized;
            }
        }
        
        // IndexedDB Storage Provider implementation
        class IndexedDBStorageProvider {
            constructor() {
                this.dbName = 'PSPStorage';
                this.storeName = 'sessions';
                this.dbPromise = this.openDatabase();
                
                // Initialize the database
                this.dbPromise.catch(error => {
                    log(`[IndexedDBProvider] Error initializing database: ${error.message}`, 'error');
                });
            }
            
            async openDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, 1);
                    
                    request.onerror = event => {
                        reject(new Error('Failed to open IndexedDB database'));
                    };
                    
                    request.onsuccess = event => {
                        resolve(event.target.result);
                    };
                    
                    request.onupgradeneeded = event => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            const store = db.createObjectStore(this.storeName, { keyPath: 'metadata.id' });
                            store.createIndex('updatedAt', 'metadata.updatedAt', { unique: false });
                        }
                    };
                });
            }
            
            async save(session) {
                try {
                    const db = await this.dbPromise;
                    const tx = db.transaction(this.storeName, 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    
                    // Serialize session for storage
                    const serialized = this.serializeSession(session);
                    
                    // Store the session
                    await new Promise((resolve, reject) => {
                        const request = store.put(serialized);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(new Error('Failed to save session to IndexedDB'));
                    });
                    
                    log(`[IndexedDBProvider] Saved session ${session.metadata.id}`);
                } catch (error) {
                    log(`[IndexedDBProvider] Error saving session: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async load(id) {
                try {
                    const db = await this.dbPromise;
                    const tx = db.transaction(this.storeName, 'readonly');
                    const store = tx.objectStore(this.storeName);
                    
                    // Get the session from IndexedDB
                    const serialized = await new Promise((resolve, reject) => {
                        const request = store.get(id);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(new Error('Failed to load session from IndexedDB'));
                    });
                    
                    if (!serialized) {
                        const error = `Session not found: ${id}`;
                        log(`[IndexedDBProvider] ${error}`, 'error');
                        throw new Error(error);
                    }
                    
                    // Deserialize the session
                    const session = this.deserializeSession(serialized);
                    log(`[IndexedDBProvider] Loaded session ${id}`);
                    return session;
                } catch (error) {
                    log(`[IndexedDBProvider] Error loading session: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async delete(id) {
                try {
                    const db = await this.dbPromise;
                    const tx = db.transaction(this.storeName, 'readwrite');
                    const store = tx.objectStore(this.storeName);
                    
                    // Delete the session
                    await new Promise((resolve, reject) => {
                        const request = store.delete(id);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(new Error('Failed to delete session from IndexedDB'));
                    });
                    
                    log(`[IndexedDBProvider] Deleted session ${id}`);
                } catch (error) {
                    log(`[IndexedDBProvider] Error deleting session: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async list() {
                try {
                    const db = await this.dbPromise;
                    const tx = db.transaction(this.storeName, 'readonly');
                    const store = tx.objectStore(this.storeName);
                    
                    // Get all sessions from IndexedDB
                    const sessions = await new Promise((resolve, reject) => {
                        const request = store.getAll();
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(new Error('Failed to list sessions from IndexedDB'));
                    });
                    
                    // Extract metadata from each session
                    const metadata = sessions.map(session => session.metadata);
                    log(`[IndexedDBProvider] Listed ${metadata.length} sessions`);
                    return metadata;
                } catch (error) {
                    log(`[IndexedDBProvider] Error listing sessions: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            async exists(id) {
                try {
                    const db = await this.dbPromise;
                    const tx = db.transaction(this.storeName, 'readonly');
                    const store = tx.objectStore(this.storeName);
                    
                    // Check if the session exists
                    const exists = await new Promise((resolve, reject) => {
                        const request = store.count(id);
                        request.onsuccess = () => resolve(request.result > 0);
                        request.onerror = () => reject(new Error('Failed to check if session exists in IndexedDB'));
                    });
                    
                    log(`[IndexedDBProvider] Session ${id} exists: ${exists}`);
                    return exists;
                } catch (error) {
                    log(`[IndexedDBProvider] Error checking if session exists: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            serializeSession(session) {
                const serialized = {
                    metadata: session.metadata,
                    state: { ...session.state }
                };
                
                // Convert localStorage Map
                if (session.state.storage?.localStorage instanceof Map) {
                    serialized.state.storage = { ...serialized.state.storage };
                    const localStorage = {};
                    
                    for (const [origin, storage] of session.state.storage.localStorage.entries()) {
                        localStorage[origin] = Object.fromEntries(storage);
                    }
                    
                    serialized.state.storage.localStorage = localStorage;
                }
                
                // Convert sessionStorage Map
                if (session.state.storage?.sessionStorage instanceof Map) {
                    serialized.state.storage = { ...serialized.state.storage };
                    const sessionStorage = {};
                    
                    for (const [origin, storage] of session.state.storage.sessionStorage.entries()) {
                        sessionStorage[origin] = Object.fromEntries(storage);
                    }
                    
                    serialized.state.storage.sessionStorage = sessionStorage;
                }
                
                return serialized;
            }
            
            deserializeSession(data) {
                const deserialized = {
                    metadata: data.metadata,
                    state: { ...data.state }
                };
                
                // Convert localStorage object to Map
                if (data.state.storage?.localStorage && typeof data.state.storage.localStorage === 'object') {
                    deserialized.state.storage = { ...deserialized.state.storage };
                    const localStorage = new Map();
                    
                    for (const [origin, storage] of Object.entries(data.state.storage.localStorage)) {
                        localStorage.set(origin, new Map(Object.entries(storage)));
                    }
                    
                    deserialized.state.storage.localStorage = localStorage;
                }
                
                // Convert sessionStorage object to Map
                if (data.state.storage?.sessionStorage && typeof data.state.storage.sessionStorage === 'object') {
                    deserialized.state.storage = { ...deserialized.state.storage };
                    const sessionStorage = new Map();
                    
                    for (const [origin, storage] of Object.entries(data.state.storage.sessionStorage)) {
                        sessionStorage.set(origin, new Map(Object.entries(storage)));
                    }
                    
                    deserialized.state.storage.sessionStorage = sessionStorage;
                }
                
                return deserialized;
            }
        }
        
        // Storage Orchestrator implementation
        class StorageOrchestrator {
            constructor(options) {
                this.primary = options.primary;
                this.secondary = options.secondary || [];
                this.useCache = options.useCache !== false;
                this.cache = new Map();
                
                log('[Orchestrator] Initialized with:');
                log(`[Orchestrator] - Primary: ${options.primary.constructor.name}`);
                log(`[Orchestrator] - Secondary: ${this.secondary.length} providers`);
                log(`[Orchestrator] - Cache enabled: ${this.useCache}`);
            }
            
            async save(session) {
                log(`[Orchestrator] Saving session ${session.metadata.id}...`);
                
                // Save to primary
                await this.primary.save(session);
                
                // Update cache
                if (this.useCache) {
                    this.cache.set(session.metadata.id, {
                        data: session,
                        timestamp: Date.now()
                    });
                    log('[Orchestrator] Updated cache');
                }
                
                // Save to secondaries
                for (const provider of this.secondary) {
                    try {
                        await provider.save(session);
                        log(`[Orchestrator] Saved to secondary: ${provider.constructor.name}`);
                    } catch (error) {
                        log(`[Orchestrator] Failed to save to secondary: ${error.message}`, 'warning');
                    }
                }
                
                log(`[Orchestrator] Session ${session.metadata.id} saved successfully`);
            }
            
            async load(id) {
                log(`[Orchestrator] Loading session ${id}...`);
                
                // Check cache first
                if (this.useCache && this.cache.has(id)) {
                    log('[Orchestrator] Found in cache');
                    return this.cache.get(id).data;
                }
                
                // Try primary
                try {
                    const session = await this.primary.load(id);
                    
                    // Update cache
                    if (this.useCache) {
                        this.cache.set(id, {
                            data: session,
                            timestamp: Date.now()
                        });
                        log('[Orchestrator] Updated cache');
                    }
                    
                    log(`[Orchestrator] Session ${id} loaded from primary`);
                    return session;
                } catch (primaryError) {
                    log('[Orchestrator] Primary load failed, trying secondaries...', 'warning');
                    
                    // Try secondaries
                    for (const provider of this.secondary) {
                        try {
                            const session = await provider.load(id);
                            
                            // Update cache
                            if (this.useCache) {
                                this.cache.set(id, {
                                    data: session,
                                    timestamp: Date.now()
                                });
                                log('[Orchestrator] Updated cache');
                            }
                            
                            log(`[Orchestrator] Session ${id} loaded from secondary`);
                            
                            // Replicate back to primary
                            try {
                                await this.primary.save(session);
                                log('[Orchestrator] Replicated to primary');
                            } catch (replicateError) {
                                log(`[Orchestrator] Failed to replicate to primary: ${replicateError.message}`, 'warning');
                            }
                            
                            return session;
                        } catch (secondaryError) {
                            // Continue to next secondary
                        }
                    }
                    
                    // If we get here, all providers failed
                    log(`[Orchestrator] Failed to load session ${id} from any provider`, 'error');
                    throw primaryError;
                }
            }
            
            async delete(id) {
                log(`[Orchestrator] Deleting session ${id}...`);
                
                // Remove from cache
                if (this.useCache) {
                    this.cache.delete(id);
                    log('[Orchestrator] Removed from cache');
                }
                
                // Delete from primary
                await this.primary.delete(id);
                log('[Orchestrator] Deleted from primary');
                
                // Delete from secondaries
                for (const provider of this.secondary) {
                    try {
                        await provider.delete(id);
                        log(`[Orchestrator] Deleted from secondary: ${provider.constructor.name}`);
                    } catch (error) {
                        log(`[Orchestrator] Failed to delete from secondary: ${error.message}`, 'warning');
                    }
                }
                
                log(`[Orchestrator] Session ${id} deleted successfully`);
            }
            
            async list(filter) {
                log('[Orchestrator] Listing sessions...');
                
                try {
                    // Use primary for listing
                    const sessions = await this.primary.list(filter);
                    log(`[Orchestrator] Listed ${sessions.length} sessions from primary`);
                    return sessions;
                } catch (primaryError) {
                    log('[Orchestrator] Primary list failed, trying secondaries...', 'warning');
                    
                    // Try secondaries
                    for (const provider of this.secondary) {
                        try {
                            const sessions = await provider.list(filter);
                            log(`[Orchestrator] Listed ${sessions.length} sessions from secondary`);
                            return sessions;
                        } catch (secondaryError) {
                            // Continue to next secondary
                        }
                    }
                    
                    // If we get here, all providers failed
                    log('[Orchestrator] Failed to list sessions from any provider', 'error');
                    throw primaryError;
                }
            }
            
            async exists(id) {
                log(`[Orchestrator] Checking if session ${id} exists...`);
                
                // Check cache first
                if (this.useCache && this.cache.has(id)) {
                    log('[Orchestrator] Found in cache');
                    return true;
                }
                
                // Try primary
                try {
                    const exists = await this.primary.exists(id);
                    log(`[Orchestrator] Session exists in primary: ${exists}`);
                    return exists;
                } catch (primaryError) {
                    log('[Orchestrator] Primary check failed, trying secondaries...', 'warning');
                    
                    // Try secondaries
                    for (const provider of this.secondary) {
                        try {
                            const exists = await provider.exists(id);
                            if (exists) {
                                log('[Orchestrator] Session exists in secondary');
                                return true;
                            }
                        } catch (secondaryError) {
                            // Continue to next secondary
                        }
                    }
                    
                    // If we get here, session doesn't exist in any provider
                    log('[Orchestrator] Session does not exist in any provider');
                    return false;
                }
            }
            
            clearCache() {
                log('[Orchestrator] Clearing cache...');
                this.cache.clear();
                log('[Orchestrator] Cache cleared');
            }
        }
        
        // Initialize storage providers
        const memoryProvider = new MemoryStorageProvider();
        const indexedDbProvider = new IndexedDBStorageProvider();
        const orchestrator = new StorageOrchestrator({
            primary: indexedDbProvider,
            secondary: [memoryProvider],
            useCache: true
        });
        
        // Current active session
        let currentSession = null;
        let lastSessionId = null;
        
        // Generate a unique ID
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2);
        }
        
        // Create a test session
        function createTestSession() {
            const id = generateId();
            return {
                metadata: {
                    id: id,
                    name: `Browser Test Session ${id.substring(0, 8)}`,
                    description: "A test session created in the browser",
                    tags: ["test", "browser", "psp"],
                    createdAt: Date.now(),
                    updatedAt: Date.now()
                },
                state: {
                    version: "1.0.0",
                    timestamp: Date.now(),
                    origin: window.location.origin,
                    storage: {
                        cookies: [
                            {
                                name: "test_cookie",
                                value: "test_value",
                                domain: window.location.hostname,
                                path: "/",
                                expires: null,
                                httpOnly: false,
                                secure: true,
                                sameSite: "Lax",
                                partitioned: false
                            }
                        ],
                        localStorage: new Map([
                            [window.location.origin, new Map([
                                ["test_key", "test_value"],
                                ["user_id", "12345"],
                                ["timestamp", Date.now().toString()]
                            ])]
                        ]),
                        sessionStorage: new Map([
                            [window.location.origin, new Map([
                                ["temp_data", "some temporary data"],
                                ["visit_count", "1"]
                            ])]
                        ])
                    }
                }
            };
        }
        
        // Display session info
        function displaySession(session) {
            if (!session) {
                document.getElementById('session-info').innerHTML = 'No session loaded';
                return;
            }
            
            currentSession = session;
            lastSessionId = session.metadata.id;
            
            const metadata = session.metadata;
            const state = session.state;
            
            // Get localStorage and sessionStorage
            const localStorage = state.storage.localStorage.get(window.location.origin) || new Map();
            const sessionStorage = state.storage.sessionStorage.get(window.location.origin) || new Map();
            
            // Format the storage maps for display
            const formatStorageMap = (map) => {
                if (!(map instanceof Map)) return 'Not a Map';
                
                const entries = [];
                for (const [key, value] of map.entries()) {
                    entries.push(`"${key}": "${value}"`);
                }
                
                return entries.length > 0
                    ? '{\n  ' + entries.join(',\n  ') + '\n}'
                    : '{}';
            };
            
            const html = `
                <h4>${metadata.name}</h4>
                <p><strong>ID:</strong> ${metadata.id}</p>
                <p><strong>Description:</strong> ${metadata.description || 'None'}</p>
                <p><strong>Created:</strong> ${new Date(metadata.createdAt).toLocaleString()}</p>
                <p><strong>Updated:</strong> ${new Date(metadata.updatedAt).toLocaleString()}</p>
                <p><strong>Tags:</strong> ${metadata.tags ? metadata.tags.join(', ') : 'None'}</p>
                
                <h4>State</h4>
                <p><strong>Origin:</strong> ${state.origin}</p>
                <p><strong>Version:</strong> ${state.version}</p>
                <p><strong>Cookies:</strong> ${state.storage.cookies.length} cookies</p>
                
                <h4>localStorage</h4>
                <pre>${formatStorageMap(localStorage)}</pre>
                
                <h4>sessionStorage</h4>
                <pre>${formatStorageMap(sessionStorage)}</pre>
            `;
            
            document.getElementById('session-info').innerHTML = html;
        }
        
        // Log function
        function log(message, type = 'info') {
            const logElement = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const formattedMessage = `[${timestamp}] ${message}`;
            
            const messageElement = document.createElement('div');
            messageElement.textContent = formattedMessage;
            
            if (type === 'error') {
                messageElement.classList.add('error');
            } else if (type === 'success') {
                messageElement.classList.add('success');
            } else if (type === 'warning') {
                messageElement.classList.add('warning');
            }
            
            logElement.appendChild(messageElement);
            logElement.scrollTop = logElement.scrollHeight;
            
            console.log(`[${type.toUpperCase()}] ${message}`);
        }
        
        // Tab switching
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
            });
        });
        
        // Memory provider actions
        document.getElementById('memory-create-btn').addEventListener('click', async () => {
            try {
                const session = createTestSession();
                await memoryProvider.save(session);
                displaySession(session);
                log('Session created in memory provider', 'success');
            } catch (error) {
                log(`Error creating session: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('memory-list-btn').addEventListener('click', async () => {
            try {
                const sessions = await memoryProvider.list();
                log(`Listed ${sessions.length} sessions from memory provider`, 'success');
                
                if (sessions.length === 0) {
                    log('No sessions found in memory provider');
                } else {
                    log('Sessions in memory provider:');
                    sessions.forEach(metadata => {
                        log(`- ${metadata.id}: ${metadata.name}`);
                    });
                }
            } catch (error) {
                log(`Error listing sessions: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('memory-load-btn').addEventListener('click', async () => {
            if (!lastSessionId) {
                log('No session ID available. Create a session first.', 'warning');
                return;
            }
            
            const id = window.prompt('Enter session ID to load:', lastSessionId);
            if (!id) return;
            
            try {
                const session = await memoryProvider.load(id);
                displaySession(session);
                log(`Loaded session ${id} from memory provider`, 'success');
            } catch (error) {
                log(`Error loading session: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('memory-delete-btn').addEventListener('click', async () => {
            if (!lastSessionId) {
                log('No session ID available. Create a session first.', 'warning');
                return;
            }
            
            const id = window.prompt('Enter session ID to delete:', lastSessionId);
            if (!id) return;
            
            try {
                await memoryProvider.delete(id);
                if (currentSession && currentSession.metadata.id === id) {
                    displaySession(null);
                }
                log(`Deleted session ${id} from memory provider`, 'success');
            } catch (error) {
                log(`Error deleting session: ${error.message}`, 'error');
            }
        });
        
        // IndexedDB provider actions
        document.getElementById('indexeddb-create-btn').addEventListener('click', async () => {
            try {
                const session = createTestSession();
                await indexedDbProvider.save(session);
                displaySession(session);
                log('Session created in IndexedDB provider', 'success');
            } catch (error) {
                log(`Error creating session: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('indexeddb-list-btn').addEventListener('click', async () => {
            try {
                const sessions = await indexedDbProvider.list();
                log(`Listed ${sessions.length} sessions from IndexedDB provider`, 'success');
                
                if (sessions.length === 0) {
                    log('No sessions found in IndexedDB provider');
                } else {
                    log('Sessions in IndexedDB provider:');
                    sessions.forEach(metadata => {
                        log(`- ${metadata.id}: ${metadata.name}`);
                    });
                }
            } catch (error) {
                log(`Error listing sessions: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('indexeddb-load-btn').addEventListener('click', async () => {
            if (!lastSessionId) {
                log('No session ID available. Create a session first.', 'warning');
                return;
            }
            
            const id = window.prompt('Enter session ID to load:', lastSessionId);
            if (!id) return;
            
            try {
                const session = await indexedDbProvider.load(id);
                displaySession(session);
                log(`Loaded session ${id} from IndexedDB provider`, 'success');
            } catch (error) {
                log(`Error loading session: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('indexeddb-delete-btn').addEventListener('click', async () => {
            if (!lastSessionId) {
                log('No session ID available. Create a session first.', 'warning');
                return;
            }
            
            const id = window.prompt('Enter session ID to delete:', lastSessionId);
            if (!id) return;
            
            try {
                await indexedDbProvider.delete(id);
                if (currentSession && currentSession.metadata.id === id) {
                    displaySession(null);
                }
                log(`Deleted session ${id} from IndexedDB provider`, 'success');
            } catch (error) {
                log(`Error deleting session: ${error.message}`, 'error');
            }
        });
        
        // Orchestrator actions
        document.getElementById('orchestrator-create-btn').addEventListener('click', async () => {
            try {
                const session = createTestSession();
                await orchestrator.save(session);
                displaySession(session);
                log('Session created using orchestrator', 'success');
            } catch (error) {
                log(`Error creating session: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('orchestrator-list-btn').addEventListener('click', async () => {
            try {
                const sessions = await orchestrator.list();
                log(`Listed ${sessions.length} sessions using orchestrator`, 'success');
                
                if (sessions.length === 0) {
                    log('No sessions found using orchestrator');
                } else {
                    log('Sessions available via orchestrator:');
                    sessions.forEach(metadata => {
                        log(`- ${metadata.id}: ${metadata.name}`);
                    });
                }
            } catch (error) {
                log(`Error listing sessions: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('orchestrator-load-btn').addEventListener('click', async () => {
            if (!lastSessionId) {
                log('No session ID available. Create a session first.', 'warning');
                return;
            }
            
            const id = window.prompt('Enter session ID to load:', lastSessionId);
            if (!id) return;
            
            try {
                const session = await orchestrator.load(id);
                displaySession(session);
                log(`Loaded session ${id} using orchestrator`, 'success');
            } catch (error) {
                log(`Error loading session: ${error.message}`, 'error');
            }
        });
        
        document.getElementById('orchestrator-delete-btn').addEventListener('click', async () => {
            if (!lastSessionId) {
                log('No session ID available. Create a session first.', 'warning');
                return;
            }
            
            const id = window.prompt('Enter session ID to delete:', lastSessionId);
            if (!id) return;
            
            try {
                await orchestrator.delete(id);
                if (currentSession && currentSession.metadata.id === id) {
                    displaySession(null);
                }
                log(`Deleted session ${id} using orchestrator`, 'success');
            } catch (error) {
                log(`Error deleting session: ${error.message}`, 'error');
            }
        });
        
        // Initialize
        log('PSP Browser Storage Test initialized', 'success');
        log('Create, load, and manage browser sessions using the buttons above');
    </script>
</body>
</html>